// package githubauth uses github's device flow api to retrieve an oauth2 access token
// https://docs.github.com/en/developers/apps/authorizing-oauth-apps#device-flow
// Device flow was chosen so the app could still function without exposing or requiring configuration of the client secret
package githubauth

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"golang.org/x/oauth2"
)

// This clientid was generated by @therealplato, you're welcome to replace it with your own generated via
// https://github.com/settings/applications/new . Be sure to provide a valid callback URL. I registered
// http://localhost:2992/oauth2/callback
const clientID = "13691b85a3d64f794bb0"

// requiredScopes is space separated string of scopes as per https://docs.github.com/en/developers/apps/scopes-for-oauth-apps
var requiredScopes string = "repo:status"

// jsonHeaders is the http headers we'll use to ensure json request/response bodies
var jsonHeaders = http.Header{
	"Accept":       []string{"application/json"},
	"Content-Type": []string{"application/json"},
}

func MustAuthorize(logger io.Writer) *oauth2.Token {
	deviceHTTPReq := mustCraftDeviceVerificationCodeRequest(logger)

	deviceHTTPRes, err := http.DefaultClient.Do(deviceHTTPReq)
	if err != nil {
		fmt.Fprintf(logger, "failed to perform device verification code http request: %q\n", err)
		os.Exit(1)
	}
	deviceRes := &deviceVerificationCodeResponse{}
	err = json.NewDecoder(deviceHTTPRes.Body).Decode(deviceRes)
	if err != nil {
		fmt.Fprintf(logger, "failed to decode device verification code response: %q\n", err)
		os.Exit(1)
	}

	// Ask user to navigate to URL and enter code
	fmt.Fprintf(logger, "Please navigate to %s, enter the code %v and check back here in a few seconds\n", deviceRes.VerificationURI, deviceRes.UserCode)
	var token *oauth2.Token
	var interval = deviceRes.Interval
	for token == nil {
		// Obey the rate limit:
		time.Sleep(time.Duration(interval) * time.Second)
		tokenHTTPReq := mustCraftTokenVerificationCodeRequest(logger, clientID, deviceRes.DeviceCode)
		res, err := http.DefaultClient.Do(tokenHTTPReq)
		if err != nil {
			fmt.Fprintf(logger, "failed to perform token http request: %q\n", err)
			os.Exit(1)
		}
		tokenRes := &tokenResponse{}
		err = json.NewDecoder(res.Body).Decode(tokenRes)
		if err != nil {
			fmt.Fprintf(logger, "failed to decode token response: %q\n", err)
			os.Exit(1)
		}
		if tokenRes.Error != "" {
			if tokenRes.Error == "authorization_pending" {
				continue
			}
			if tokenRes.Error == "slow_down" {
				if tokenRes.Interval == 0 {
					fmt.Fprint(logger, "API asked us to slow down but could not find the new rate.\n")
					os.Exit(1)
				}
				fmt.Fprintf(logger, "API asked us to slow down, new rate is %v seconds.\n", tokenRes.Interval)
				interval = tokenRes.Interval
				continue
			}
			fmt.Fprintf(logger, "unhandled token error response: %q\n%q\n%q\n", tokenRes.Error, tokenRes.ErrorDescription, tokenRes.ErrorURI)
			os.Exit(1)
		}
		token = &oauth2.Token{
			AccessToken: tokenRes.AccessToken,
			TokenType:   tokenRes.TokenType,
		}
	}

	return token
}

type tokenRequest struct {
	ClientID   string `json:"client_id"`
	DeviceCode string `json:"device_code"`
	GrantType  string `json:"grant_type"`
}
type tokenResponse struct {
	AccessToken      string `json:"access_token"`
	TokenType        string `json:"token_type"`
	Scope            string `json:"scope"`
	Error            string `json:"error"`
	ErrorDescription string `json:"error_description"`
	ErrorURI         string `json:"error_uri"`
	Interval         int    `json:"interval"`
}

func mustCraftTokenVerificationCodeRequest(logger io.Writer, clientID, deviceCode string) *http.Request {
	req := &tokenRequest{
		ClientID:   clientID,
		DeviceCode: deviceCode,
		GrantType:  "urn:ietf:params:oauth:grant-type:device_code",
	}
	bb, err := json.Marshal(req)
	if err != nil {
		fmt.Fprintf(logger, "could not marshal token request: %q\n", err)
		os.Exit(1)
	}
	buf := bytes.NewBuffer(bb)
	tokenHTTPReq, err := http.NewRequest(http.MethodPost, "https://github.com/login/oauth/access_token", buf)
	if err != nil {
		fmt.Fprintf(logger, "could not construct token http request: %q\n", err)
		os.Exit(1)
	}
	tokenHTTPReq.Header = jsonHeaders
	return tokenHTTPReq
}

var deviceVerificationCodeURL = "https://github.com/login/device/code"

type deviceVerificationCodeRequest struct {
	// ClientID is this application's client id
	ClientID string `json:"client_id"`

	// Scope is space separated list
	Scope string `json:"scope"`
}

type deviceVerificationCodeResponse struct {
	// DeviceCode is our half of the challenge
	DeviceCode string `json:"device_code"`

	// UserCode is users half of the challenge
	UserCode string `json:"user_code"`

	// VerificationURI is where user enters UserCode
	VerificationURI string `json:"verification_uri"`

	// ExpiresIn is how long user has
	ExpiresIn int `json:"expires_in"`

	// Interval is seconds until rate limiting allows next request
	Interval int `json:"interval"`
}

func mustCraftDeviceVerificationCodeRequest(logger io.Writer) *http.Request {
	req := deviceVerificationCodeRequest{
		ClientID: clientID,
		Scope:    requiredScopes,
	}
	bb, err := json.Marshal(req)
	if err != nil {
		fmt.Fprintf(logger, "could not marshal device verification code request: %q\n", err)
		os.Exit(1)
	}
	buf := bytes.NewBuffer(bb)

	initialRequest, err := http.NewRequest(http.MethodPost, deviceVerificationCodeURL, buf)
	if err != nil {
		fmt.Fprintf(logger, "could not construct device verification code http request: %q\n", err)
		os.Exit(1)
	}
	initialRequest.Header = jsonHeaders

	return initialRequest
}
